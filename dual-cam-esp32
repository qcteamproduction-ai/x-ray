import streamlit as st
import cv2
import time
import serial
from ultralytics import YOLO
from collections import deque

# === Custom CSS ===
st.markdown("""
    <style>
    #MainMenu, footer, header {visibility: hidden;}
    .block-container {padding: 0.5rem 1rem; max-width: 100%;}
    .status-bar {width: 100vw; margin-left: calc(-50vw + 50%); padding: 1.5rem 0; text-align: center;
                 box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); transition: all 0.3s ease;}
    @keyframes pulse {0%,100%{opacity:1;} 50%{opacity:0.85;}}
    @keyframes glow {0%{text-shadow:0 0 5px rgba(255,255,255,0.6);}
                     50%{text-shadow:0 0 25px rgba(255,255,255,1);}
                     100%{text-shadow:0 0 5px rgba(255,255,255,0.6);}}
    .status-danger {animation: pulse 1.5s infinite, glow 2s infinite;}
    .status-pass {animation: glow 3s infinite;}
    .frame-container {border-radius: 8px; overflow: hidden; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
                      background: #f8f9fa; padding: 0.5rem; height: 100%;}
    .camera-label {text-align: center; font-size: 1.5rem; font-weight: bold; 
                   margin-bottom: 1rem; color: #667eea;}
    .serial-status {text-align: center; padding: 0.5rem; margin: 1rem 0; border-radius: 5px;
                    font-weight: bold; font-size: 0.9rem;}
    .serial-connected {background: #d4edda; color: #155724; border: 1px solid #c3e6cb;}
    .serial-disconnected {background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;}
    </style>
""", unsafe_allow_html=True)

# === Initialize Serial Connection ===
serial_placeholder = st.empty()
try:
    ser = serial.Serial('COM3', 9600, timeout=1)
    time.sleep(2)  # Wait for serial connection to establish
    serial_status = "connected"
    serial_placeholder.markdown(
        "<div class='serial-status serial-connected'>‚úì ESP32 Connected (COM3)</div>",
        unsafe_allow_html=True
    )
except Exception as e:
    ser = None
    serial_status = "disconnected"
    serial_placeholder.markdown(
        f"<div class='serial-status serial-disconnected'>‚úó ESP32 Not Connected: {str(e)}</div>",
        unsafe_allow_html=True
    )

# === Load YOLO model ===
model = YOLO("newest-x-ray-model.pt")

# === Open cameras ===
cap1 = cv2.VideoCapture(0)  # Camera 1
cap2 = cv2.VideoCapture(1)  # Camera 2

if not cap1.isOpened() or not cap2.isOpened():
    st.error("Error: Could not open one or both cameras. Please check your camera connections.")
    st.stop()

# Set camera resolution
cap1.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap1.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
cap2.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap2.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# === History buffers for both cameras ===
history_cam1 = deque(maxlen=3)
history_cam2 = deque(maxlen=3)

# === Status placeholder ===
status_placeholder = st.empty()

# === Create two columns for cameras ===
col_left, col_right = st.columns([1, 1])

with col_left:
    st.markdown("<p class='camera-label'>Camera 1</p>", unsafe_allow_html=True)
    st.markdown("<div class='frame-container'>", unsafe_allow_html=True)
    frame_placeholder_1 = st.empty()
    st.markdown("</div>", unsafe_allow_html=True)

with col_right:
    st.markdown("<p class='camera-label'>Camera 2</p>", unsafe_allow_html=True)
    st.markdown("<div class='frame-container'>", unsafe_allow_html=True)
    frame_placeholder_2 = st.empty()
    st.markdown("</div>", unsafe_allow_html=True)

# === Control variables ===
danger_start_time = None
danger_duration = 5
relay_triggered = False

# === Function to send command to ESP32 ===
def trigger_relay():
    if ser and ser.is_open:
        try:
            ser.write(b'RELAY_ON\n')
            return True
        except Exception as e:
            st.warning(f"Failed to send command to ESP32: {str(e)}")
            return False
    return False

# === Main loop ===
while True:
    # Read from both cameras
    ret1, frame1 = cap1.read()
    ret2, frame2 = cap2.read()
    
    if not ret1 or not ret2:
        st.error("Camera connection lost. Please check your cameras.")
        break

    # === Process Camera 1 ===
    results1 = model.predict(frame1, imgsz=1280, verbose=False)
    detected_cam1 = False
    
    for r in results1:
        for c in r.boxes.cls:
            class_name = model.names[int(c)]
            if class_name.lower() == "material":
                detected_cam1 = True
                break

    # === Process Camera 2 ===
    results2 = model.predict(frame2, imgsz=1280, verbose=False)
    detected_cam2 = False
    
    for r in results2:
        for c in r.boxes.cls:
            class_name = model.names[int(c)]
            if class_name.lower() == "material":
                detected_cam2 = True
                break

    # Save to buffers
    history_cam1.append(detected_cam1)
    history_cam2.append(detected_cam2)

    # === Status logic (DANGER if either camera detects material consistently) ===
    current_time = time.time()

    # If either camera detects "Material" in all 3 recent frames (OR logic)
    if (len(history_cam1) == 3 and all(history_cam1)) or (len(history_cam2) == 3 and all(history_cam2)):
        if not relay_triggered:
            # Trigger relay on ESP32
            if trigger_relay():
                relay_triggered = True
                danger_start_time = current_time
                st.toast("üö® Material detected! Relay activated for 5 seconds", icon="‚ö†Ô∏è")
            
        # Clear the buffer that triggered
        if len(history_cam1) == 3 and all(history_cam1):
            history_cam1.clear()
        if len(history_cam2) == 3 and all(history_cam2):
            history_cam2.clear()

    # Display status based on danger timer
    if danger_start_time and (current_time - danger_start_time) < danger_duration:
        status = "DANGER"
        status_text = f"Relay Active: {danger_duration - int(current_time - danger_start_time)}s remaining"
        bg_gradient = "linear-gradient(135deg, #dc3545 0%, #c82333 100%)"
        animation_class = "status-danger"
    else:
        status = "PASS"
        status_text = "System Normal"
        bg_gradient = "linear-gradient(135deg, #28a745 0%, #218838 100%)"
        animation_class = "status-pass"
        # Reset timer and relay flag if 5 seconds passed
        if danger_start_time and (current_time - danger_start_time) >= danger_duration:
            danger_start_time = None
            relay_triggered = False

    # === Display status bar ===
    status_placeholder.markdown(f"""
        <div class='status-bar {animation_class}' style='background: {bg_gradient};'>
            <div style='display:flex; align-items:center; justify-content:center; gap:1rem;'>
                <div style='text-align:center;'>
                    <h1 style='color:white; margin:0; font-size:4rem; font-weight:1000;
                               text-transform:uppercase; letter-spacing:6px;
                               text-shadow:0 0 10px rgba(0,0,0,0.8),
                                            0 0 25px rgba(0,0,0,0.6),
                                            2px 2px 8px rgba(0,0,0,0.4);'>
                        {status}
                    </h1>
                    <p style='color:white; margin:0; font-size:1.2rem; opacity:0.9;'>{status_text}</p>
                </div>
            </div>
        </div>
    """, unsafe_allow_html=True)

    # === Display annotated frames ===
    annotated_frame1 = results1[0].plot()
    annotated_frame2 = results2[0].plot()
    
    frame_placeholder_1.image(annotated_frame1, channels="BGR", use_container_width=True)
    frame_placeholder_2.image(annotated_frame2, channels="BGR", use_container_width=True)

# Release cameras and serial connection
cap1.release()
cap2.release()
if ser and ser.is_open:
    ser.close()
